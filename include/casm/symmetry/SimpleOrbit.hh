#ifndef CASM_symmetry_SimpleOrbit
#define CASM_symmetry_SimpleOrbit

#include <vector>

namespace CASM {

  template<typename _SymCompareType>
  struct SimpleOrbitElementCompare {

    typedef _SymCompareType SymCompareType;
    typedef typename _SymCompareType::Element Element;

    SymCompareType sym_compare;

    SimpleOrbitElementCompare(SymCompareType const &_sym_compare);

    bool operator()(const Element &A, const Element &B) const;
  };

  /// Generate an orbit of unique Element generated by a group of SymOp or PermuteIterator
  ///
  /// SimpleOrbit is similar to Orbit, but does not maintain the generating group or equivalence map
  /// and element sorting is not based on the equivalence map.
  ///
  /// \ingroup OrbitGeneration
  ///
  template<typename _SymCompareType>
  class SimpleOrbit {
  public:

    typedef _SymCompareType SymCompareType;
    typedef typename SymCompareType::Element;
    typedef typename SymCompareType::InvariantsType;

    /// Construct a SimpleOrbit using a range of SymOp or PermuteIterator
    template<typename GroupIterator>
    SimpleOrbit(typename SymCompareType::Element const &_generating_element,
                GroupIterator _group_begin,
                GroupIterator _group_end,
                SymCompareType const &_sym_compare);

    const_iterator begin() const {
      return m_element.cbegin();
    }

    const_iterator end() const {
      return m_element.cend();
    }

    const_iterator cbegin() const {
      return m_element.cbegin();
    }

    const_iterator cend() const {
      return m_element.cend();
    }

    size_type size() const {
      return m_element.size();
    }

    /// \brief Identical to element(0)
    const Element &prototype() const {
      return m_element[0];
    }

    /// \brief Return Element at index, without bounds checking
    ///
    /// - May not be prepared
    const Element &operator[](size_type index) const {
      return element(index);
    }

    /// \brief Equivalent to operator[](size_type index) const
    ///
    /// - May not be prepared
    const Element &element(size_type index) const {
      return m_element[index];
    }

    /// \brief const Access vector of Element
    ///
    /// - May not be prepared
    const std::vector<Element> &elements() const {
      return m_element;
    }

    /// \brief Return the SymCompare functor reference
    ///
    /// - implements symmetry properties of this orbit
    const SymCompareType &sym_compare() const {
      return m_sym_compare;
    }

    InvariantsType const &invariants() const {
      return m_invariants;
    }

    /// Compare orbits, using SymCompareType::inter_orbit_compare
    bool operator<(const Orbit &B) const;

  private:
    SymCompareType m_sym_compare;
    InvariantsType m_invariants;
    std::vector<Element> m_elements;
  };
}

#endif
