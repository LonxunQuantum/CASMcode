#ifndef CASM_Orbit_impl
#define CASM_Orbit_impl

#include <set>
#include <boost/iterator/transform_iterator.hpp>
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>
#include "casm/symmetry/Orbit.hh"
#include "casm/symmetry/SymGroup.hh"
#include "casm/misc/algorithm.hh"
#include "casm/kinetics/PrimPeriodicDiffTransOrbitTraits.hh"
#include "casm/casm_io/jsonParser.hh"
#include "casm/casm_io/json_io/container.hh"
#include "casm/crystallography/Lattice.hh"
#include "casm/clex/PrimClex.hh"
#include "casm/database/Named.hh"
#include "casm/database/Database.hh"
#include "casm/app/DirectoryStructure.hh"

namespace CASM {

  namespace Orbit_impl {

    // -- Sort using indices ---

    struct EqMapRow {

      /// generate eq_map row for tmp_element[b] relative to tmp_element[a]
      ///
      /// Notes:
      ///   tmp_element[a] == g[tmp_eq_map[a][j]]*tmp_proto; // for all j
      ///   tmp_element[b] == g[tmp_eq_map[b][j]]*tmp_proto; // for all j
      ///   a2proto = g.ind_inverse(tmp_eq_map[a][0]);
      ///   tmp_element[b] == g[tmp_eq_map[b][j]]*g[a2proto]*tmp_element[a]; // for all j

      EqMapRow(Index _a, Index _b, const std::vector<std::vector<Index>> &tmp_eq_map, const SymGroup &g):
        a(_a), b(_b) {
        try {
          Index a2proto = g.ind_inverse(tmp_eq_map[a][0]);
          for(Index j = 0; j < tmp_eq_map[b].size(); ++j) {
            values.emplace(g.ind_prod(tmp_eq_map[b][j], a2proto));
          }
        }
        catch(const std::exception &e) {
          default_err_log() << "Error in GenericOrbit constructor: \n"
                            << "  Failed constructing EqMapRow." << std::endl;
          throw e;
        }
      };

      Index a; // 'a' in tmp_eq_map[a][j]
      Index b; // 'b' in tmp_eq_map[b][j]
      std::set<Index> values;  // equivalence_map for b, relative to a

      bool operator<(const EqMapRow &other) const {
        return this->values < other.values;
      }
    };

    struct RelEqMap {

      /// generate eq_map row for tmp_element[b] relative to tmp_element[a]
      RelEqMap(Index _a, const std::vector<std::vector<Index>> &tmp_eq_map, const SymGroup &g):
        a(_a) {
        try {
          for(Index b = 0; b < tmp_eq_map.size(); ++b) {
            map.emplace(a, b, tmp_eq_map, g);
          }
        }
        catch(const std::exception &e) {
          default_err_log() << "Error in GenericOrbit constructor: \n"
                            << "  Failed constructing RelEqMap." << std::endl;
          throw e;
        }
      }

      Index a; // 'a' in tmp_eq_map[a]
      std::set<EqMapRow> map;  // equivalence_map for b, relative to a

      bool operator<(const RelEqMap &other) const {
        return this->map < other.map;
      }
    };

    std::ostream &operator<<(std::ostream &sout, const RelEqMap &map);

  }

  /* -- Orbit Definitions ------------------------------------- */

  /// \brief Construct an Orbit from a generating_element Element, using provided Group
  ///
  /// \param generating_element The element used to generate equivalents
  /// \param generating_group The group used for generating the orbit
  /// \param sym_compare Binary functor that implements symmetry properties
  ///
  template<typename _Element, typename _SymCompareType>
  GenericOrbit<_Element, _SymCompareType>::GenericOrbit(Element generating_element,
                                                        const SymGroup &generating_group,
                                                        const _SymCompareType &sym_compare) :
    m_generating_group(generating_group),
    m_sym_compare(sym_compare) {

    // element(i) compares equivalent to prototype().copy_apply(equivalence_map[i][j]) for all j

    //  X   :   op(0)   op(1)   ...
    // proto:    0       ?       ?   (<-- proto.invariant_subgroup(g, sym_compare))
    // el(1):  (the element generated by the first op that doesn't result in proto)
    // el(2):  (the element generated by the first op that doesn't result in proto or el(1))
    //  ... :  ( etc. )

    // get tmp_elements w/ generating_element & g+sym_compare
    // get tmp_equivalence_map from tmp_elements...
    // use tmp_equivalence_map to generate equivalence_maps using the other
    //   elements as the prototype
    // use the element with the 'lowest' equivalence_map as the prototype

    const SymGroup &g = generating_group;

    auto compare = [&](const Element & A, const Element & B) {
      return m_sym_compare.compare(A, B);
    };


    // generate equivalents using std::map to remove duplicates
    // store ordered symop indices corresponding to transformations for each equivalent
    std::map<Element, std::set<Index>, decltype(compare)> t_equiv(compare);
    try {
      for(Index i = 0; i < g.size(); i++) {
        t_equiv[m_sym_compare.prepare(copy_apply(g[i], generating_element))].insert(i); // not g[i].index()!!;
      }
    }
    catch(const std::exception &e) {
      default_err_log() << "Error in GenericOrbit constructor: \n"
                        << "  Failed generating unique equivalents." << std::endl;
      throw e;
    }

    // generate equivalence_map w/ tmp ordering
    std::vector<Element> tmp_element;
    std::vector<std::vector<Index>> tmp_equivalence_map;
    try {
      Index first2proto = g.ind_inverse(*(t_equiv.begin()->second.begin()));

      for(auto const &_equiv : t_equiv) {
        tmp_element.push_back(_equiv.first);
        tmp_equivalence_map.emplace_back();
        for(Index op_i : _equiv.second) {
          tmp_equivalence_map.back().push_back(g.ind_prod(op_i, first2proto));
        }
      }

      // sanity check that equivalence_map is rectangular
      for(Index j = 1; j < tmp_equivalence_map.size(); ++j) {
        if(tmp_equivalence_map[0].size() != tmp_equivalence_map[j].size()) {
          jsonParser json;
          default_err_log() << "SymGroup, Symmetry application, or SymCompareType error: "
                            "initial equivalence map is not rectangular: \n"
                            << to_json(tmp_equivalence_map, json) << std::endl;
          throw std::runtime_error("Error in GenericOrbit constructor: equivalence map is not rectangular");
        }
      }
    }
    catch(const std::exception &e) {
      default_err_log() << "Error in GenericOrbit constructor: \n"
                        << "  Failed generating initial equivalence map." << std::endl;
      throw e;
    }

    /// find the best equivalence map out of all possible
    ///   (lowest lexicographical sorting columnwise)
    /// ties are resolved by virtue of fact that 'tmp_element' is already sorted by m_sym_compare.compare
    Index best_a = 0;
    Orbit_impl::RelEqMap best(best_a, tmp_equivalence_map, g);
    try {
      for(Index a = 1; a < tmp_equivalence_map.size(); ++a) {
        Orbit_impl::RelEqMap test(a, tmp_equivalence_map, g);

        std::cout << "\n\nBEST:\n" << best << "\n" << tmp_element[best_a] << "TEST:\n" << test <<  "\n" << tmp_element[a] << "\n";
        if(test < best) {
          best_a = a;
          best = std::move(test);
          std::cout << "++ TEST IS BETTER THAN BEST\n";
        }
        else if(best < test)
          std::cout << "-- BEST IS BETTER THAN TEST\n";
        else
          std::cout << "== BEST IS EQUAL TO TEST\n";



      }
    }
    catch(const std::exception &e) {
      default_err_log() << "Error in GenericOrbit constructor: \n"
                        << "  Failed generating sorted equivalence map." << std::endl;
      throw e;
    }

    /// copy results
    try {
      Index newproto_i = best.map.begin()->b;

      //Loop over equivalents 'i'
      for(const auto &row : best.map) {

        //Index of group element that maps proto to equiv 'i'
        Index proto2i = *(row.values.begin());

        Element tequiv = m_sym_compare.prepare(copy_apply(g[proto2i], tmp_element[newproto_i]));
        SymOp ttrans = m_sym_compare.spatial_transform();

        m_element.push_back(copy_apply(ttrans * g[proto2i], tmp_element[newproto_i]));
        m_equivalence_map.emplace_back();
        // Loop over elements 'j' of new, sorted clust_group (0 row of best.map)
        for(const auto &cg_j : best.map.begin()->values) {
          Index value = g.ind_prod(proto2i, cg_j);

          tequiv = m_sym_compare.prepare(copy_apply(g[value], tmp_element[newproto_i]));
          ttrans = m_sym_compare.spatial_transform();


          m_equivalence_map.back().push_back(ttrans * g[value]);

        }
      }
    }
    catch(const std::exception &e) {
      default_err_log() << "Error in GenericOrbit constructor: \n"
                        << "  Failed copying sorted elements and equivalence map." << std::endl;
      throw e;
    }

    if(m_equivalence_map[0][0].index() != 0) {
      throw std::runtime_error("Error in GenericOrbit constructor: First equivalence map element is not identity.");
    }
  }

  /// \brief Apply symmetry to Orbit
  template<typename _Element, typename _SymCompareType>
  GenericOrbit<_Element, _SymCompareType> &GenericOrbit<_Element, _SymCompareType>::apply_sym(const SymOp &op) {

    // transform elements
    for(auto it = m_element.begin(); it != m_element.end(); ++it) {
      it->apply_sym(op);
    }

    // transform equivalence map: std::vector<std::vector<SymOp> >
    for(auto it = m_equivalence_map.begin(); it != m_equivalence_map.end(); ++it) {
      for(auto op_it = it->begin(); op_it != it->end(); ++op_it) {
        op_it->apply_sym(op);
      }
    }

    // transform sym_compare functor
    m_sym_compare.apply_sym(op);

    return *this;
  }

  template<typename _Element, typename _SymCompareType>
  void GenericOrbit<_Element, _SymCompareType>::_construct_canonization_rep() const {
    if(equivalence_map().size() == 0)
      throw std::runtime_error("In GenericOrbit::_construct_canonization_rep(), equivalence_map is uninitialized or empty! Cannot continue.");

    if(size() == 0) {
      m_canonization_rep_ID = SymGroupRepID::identity(0);
      return;
    }

    m_canonization_rep_ID = equivalence_map()[0][0].master_group().add_empty_representation();

    for(Index j = 0; j < equivalence_map()[0].size(); j++) {
      std::unique_ptr<SymOpRepresentation> new_rep = m_sym_compare.canonical_transform(copy_apply(equivalence_map()[0][j], prototype()))->inverse();

      for(Index i = 0; i < equivalence_map().size(); i++) {
        equivalence_map()[i][j].set_rep(m_canonization_rep_ID, *new_rep);
      }
    }
    return;
  }


  /// \brief Find orbit containing an element in a range of Orbit<ClusterType>
  ///
  /// \param begin,end Range of Orbit
  /// \param e Element to find
  ///
  /// \returns Iterator to Orbit containing e, or end if not found
  ///
  /// - Expects `typename std::iterator_traits<OrbitIterator>::value_type` to
  ///   be the Orbit<Element, SymCompareType> type
  /// - Expects `e` to be `prepared` via `SymCompareType::prepare`
  /// - Assume range of orbit is sorted according to `SymCompareType::invariants_compare`
  /// - Uses `SymCompareType::compare` (via `Orbit::contains`) to check for
  ///   element in orbit
  template<typename OrbitIterator, typename Element>
  OrbitIterator find_orbit(OrbitIterator begin, OrbitIterator end, Element e) {

    typedef typename std::iterator_traits<OrbitIterator>::value_type orbit_type;
    const auto &sym_compare = begin->sym_compare();

    // first find range of possible orbit by checking invariants
    auto compare = [&](const Element & A, const Element & B) {
      return sym_compare.invariants_compare(A.invariants(), B.invariants());
    };
    auto _range = std::equal_range(prototype_iterator(begin), prototype_iterator(end), e, compare);

    // find if any of the orbits in range [_range.first, _range.second) contain equivalent
    auto contains = [&](const orbit_type & orbit) {
      return orbit.contains(e);
    };
    auto res = std::find_if(_range.first.base(), _range.second.base(), contains);
    if(res == _range.second.base()) {
      return end;
    }
    return res;
  }

  /// \brief Construct an Orbit from a generating_element Element, using provided symmetry group
  ///
  /// \param generating_element One element in the orbit
  /// \param generating_group SymGroup applied to generating_element to generate
  ///        equivalents in the orbit
  /// \param sym_compare Implements element comparisons
  /// \param _primclex PrimClex pointer. May be nullptr if only the GenericOrbit
  ///        interface is needed, but this is probably the less likely use case
  ///        so it must be explicitly given.
  template<typename _Element, typename _SymCompareType>
  DatabaseTypeOrbit<_Element, _SymCompareType>::DatabaseTypeOrbit(Element generating_element,
                                                                  const SymGroup &generating_group,
                                                                  const SymCompareType &sym_compare,
                                                                  const PrimClex *_primclex) :
    GenericOrbit<_Element, _SymCompareType>(generating_element, generating_group, sym_compare),
    m_primclex(_primclex) {}

  template<typename _Element, typename _SymCompareType>
  void DatabaseTypeOrbit<_Element, _SymCompareType>::write_pos() const {
    const auto &dir = primclex().dir();
    try {
      fs::create_directories(dir.configuration_dir(this->name()));
    }
    catch(const fs::filesystem_error &ex) {
      std::cerr << "Error in DatabaseTypeOrbit::write_pos(): could not create_directories" << std::endl;
      std::cerr << ex.what() << std::endl;
    }

    fs::ofstream file(dir.POS(this->name()));
    write_pos(file);
  }

  template<typename _Element, typename _SymCompareType>
  void DatabaseTypeOrbit<_Element, _SymCompareType>::write_pos(std::ostream &sout) const {
    OrbitTraits<_Element, _SymCompareType>::write_pos(*this, sout);
  }

  template<typename _Element, typename _SymCompareType>
  const PrimClex &DatabaseTypeOrbit<_Element, _SymCompareType>::primclex() const {
    if(!m_primclex) {
      throw std::runtime_error("DatabaseTypeOrbit primclex pointer was not set");
    }
    return *m_primclex;
  }

  template<typename _Element, typename _SymCompareType>
  std::string DatabaseTypeOrbit<_Element, _SymCompareType>::generate_name_impl() const {
    return OrbitTraits<_Element, _SymCompareType>::generate_name_impl(*this);
  }

  template<typename _Element, typename _SymCompareType>
  void DatabaseTypeOrbit<_Element, _SymCompareType>::set_primclex(const PrimClex *_primclex) {
    m_primclex = _primclex;
  }

}

#endif
