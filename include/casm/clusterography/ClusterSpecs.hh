#ifndef CASM_ClusterSpecs
#define CASM_ClusterSpecs

#include <vector>

#include "casm/clusterography/ClusterOrbits.hh"
#include "casm/container/Permutation.hh"
#include "casm/crystallography/DoFDecl.hh"
#include "casm/global/enum.hh"
#include "casm/misc/cloneable_ptr.hh"
#include "casm/symmetry/PermuteIterator.hh"
#include "casm/symmetry/SymGroup.hh"

namespace CASM {

class SupercellSymInfo;
class SymGroup;

/** \defgroup ClusterSpecs

    \brief ClusterSpecs Generate IntegralCluster orbits of specific types
    \ingroup Clusterography
    \ingroup IntegralCluster

*/

/// Base class, enables runtime choice of which orbit type is generated via
/// input file parameters
///
/// Note:
/// - Most users will not use this class directly
/// - Use `for_all_orbits` template functions to implement methods that are
/// independent of orbit type
class ClusterSpecs : public notstd::Cloneable {
  ABSTRACT_CLONEABLE(ClusterSpecs)
 public:
  typedef std::vector<IntegralCluster> IntegralClusterVec;
  typedef std::vector<PrimPeriodicOrbit<IntegralCluster>> PeriodicOrbitVec;
  typedef std::vector<LocalOrbit<IntegralCluster>> LocalOrbitVec;

  /// This is the orbit generation method name
  std::string name() const;
  CLUSTER_PERIODICITY_TYPE periodicity_type() const;

  PeriodicOrbitVec make_periodic_orbits(
      IntegralClusterVec const &generating_elements) const;
  PeriodicOrbitVec make_periodic_orbits(std::ostream &status) const;

  LocalOrbitVec make_local_orbits(
      IntegralClusterVec const &generating_elements) const;
  LocalOrbitVec make_local_orbits(std::ostream &status) const;


 private:
  virtual std::string _name() const = 0;
  virtual CLUSTER_PERIODICITY_TYPE _periodicity_type() const = 0;

  virtual PeriodicOrbitVec _make_periodic_orbits(
      IntegralClusterVec const &generating_elements) const;
  virtual PeriodicOrbitVec _make_periodic_orbits(std::ostream &status) const;

  virtual LocalOrbitVec _make_local_orbits(
      IntegralClusterVec const &generating_elements) const;
  virtual LocalOrbitVec _make_local_orbits(std::ostream &status) const;

};

/// Call functor for orbits generated by ClusterSpecs
///
/// Selects the correct make_X_orbits method and then calls f for all orbits, as
/// with: \code auto orbits = cluster_specs.make_X_orbits(generating_elements);
/// f(orbits);
/// \endcode
///
/// The FunctorType should have the template method:
/// \code
/// template<typename OrbitVecType>
/// void FunctorType::operator()(OrbitVecType const &orbits) const;
/// \endcode
template <typename FunctorType>
void for_all_orbits(ClusterSpecs const &cluster_specs,
                    std::vector<IntegralCluster> const &generating_elements,
                    FunctorType const &f);

/// Call functor for orbits generated by ClusterSpecs
///
/// Selects the correct make_X_orbits method and then calls f for all orbits, as
/// with: \code auto orbits = cluster_specs.make_X_orbits(status); f(orbits);
/// \endcode
///
/// The FunctorType should have the template method:
/// \code
/// template<typename OrbitVecType>
/// void FunctorType::operator()(OrbitVecType const &orbits) const;
/// \endcode
template <typename FunctorType>
void for_all_orbits(ClusterSpecs const &cluster_specs, std::ostream &status,
                    FunctorType const &f);

/// Parameters most commonly used for periodic orbit generation
///
/// See member variables for descriptions
class PeriodicMaxLengthClusterSpecs : public ClusterSpecs {
  CLONEABLE(PeriodicMaxLengthClusterSpecs)
 public:
  static std::string const method_name; /*periodic_max_length*/

  /// Constructor
  PeriodicMaxLengthClusterSpecs(std::shared_ptr<Structure const> _shared_prim,
                                SymGroup const &_generating_group,
                                SiteFilterFunction const &_site_filter,
                                std::vector<double> const &_max_length,
                                std::vector<IntegralClusterOrbitGenerator> const
                                    &_custom_generators = {});

  /// The prim
  std::shared_ptr<Structure const> shared_prim;

  /// The group used to generate orbits, most commonly
  /// shared_prim->factor_group()
  SymGroup generating_group;

  /// The comparisons used for orbit generation
  PrimPeriodicSymCompare<IntegralCluster> sym_compare;

  /// A filter which excludes sites that are part of the unit cell neighborhood
  /// from being included in orbits. If `site_filter(site)==true`, then the site
  /// is included, else excluded.
  SiteFilterFunction site_filter;

  /// Specifies filter for truncating orbits, by orbit branch. The value
  /// max_length[b], is the max site-to-site distance for clusters to be
  /// included in branch b.
  ///
  /// Notes:
  /// - The null cluster orbit must be included (max_length.size() >= 1) or
  ///   the constructor will throw
  /// - The max_length value for the null cluster (b==0) and point cluster
  ///   orbits (b==1) does not matter. The presence of the value indicates that
  ///   null cluster and point cluster orbits should be included.
  std::vector<double> max_length;

  /// Specifies particular clusters that should be used to generate orbits.
  std::vector<IntegralClusterOrbitGenerator> custom_generators;

 private:
  std::string _name() const override;
  CLUSTER_PERIODICITY_TYPE _periodicity_type() const override;

  PeriodicOrbitVec _make_periodic_orbits(
      IntegralClusterVec const &generating_elements) const override;
  PeriodicOrbitVec _make_periodic_orbits(std::ostream &status) const override;
};

/// Parameters most commonly used for local orbit generation
class LocalMaxLengthClusterSpecs : public ClusterSpecs {
  CLONEABLE(LocalMaxLengthClusterSpecs)
 public:
  static std::string const method_name; /*local_max_length*/

  LocalMaxLengthClusterSpecs(std::shared_ptr<Structure const> _shared_prim,
                             SymGroup const &_generating_group,
                             IntegralCluster const &_phenomenal,
                             SiteFilterFunction const &_site_filter,
                             std::vector<double> const &_max_length,
                             std::vector<double> const &_cutoff_radius,
                             bool _include_phenomenal_sites,
                             std::vector<IntegralClusterOrbitGenerator> const
                                 &_custom_generators = {});

  /// The prim
  std::shared_ptr<Structure const> shared_prim;

  /// The invariant group of the phenomenal object, used to generate local
  /// orbits
  SymGroup generating_group;

  /// The comparisons used for orbit generation
  LocalSymCompare<IntegralCluster> sym_compare;

  /// Phenomenal cluster, used to find local neighborhood
  IntegralCluster phenomenal;

  /// A filter which excludes sites that are part of the local neighborhood from
  /// being included in orbits. If `site_filter(site)==true`, then the site is
  /// included, else excluded.
  SiteFilterFunction site_filter;

  /// Specifies filter for truncating orbits, by orbit branch. The value
  /// max_length[b], is the max site-to-site distance within a cluster for that
  /// cluster to be included in branch b. The b==0 value is ignored.
  ///
  /// Notes:
  /// - The null cluster orbit must be included (max_length.size() >= 1) or
  ///   the constructor will throw
  /// - The max_length value for the null cluster (b==0) does not matter. The
  ///   presence of the value indicates that null cluster orbit should be
  ///   included.
  std::vector<double> max_length;

  /// Specifies the site-to-site cutoff radius for sites to be considered part
  /// of the local neighborhood, by orbit branch. For a site to be added to
  /// clusters in branch b it must be a distance less than cutoff_radius[b] to
  /// any site in the phenomenal cluster. The b==0 value is ignored.
  std::vector<double> cutoff_radius;

  /// If true, local clusters include phenomenal_cluster sites; otherwise they
  /// do not
  bool include_phenomenal_sites;

  /// Specifies particular clusters that should be used to generate orbits.
  std::vector<IntegralClusterOrbitGenerator> custom_generators;

 private:
  std::string _name() const override;
  CLUSTER_PERIODICITY_TYPE _periodicity_type() const override;

  LocalOrbitVec _make_local_orbits(
      IntegralClusterVec const &generating_elements) const override;
  LocalOrbitVec _make_local_orbits(std::ostream &status) const override;
};


/// Parameters for the most generic orbit generation method currently
/// implemented
class GenericPeriodicClusterSpecs : public ClusterSpecs {
  CLONEABLE(GenericPeriodicClusterSpecs)

  typedef PrimPeriodicSymCompare<IntegralCluster> SymCompareType;

  GenericPeriodicClusterSpecs(
      std::string _method_name, std::shared_ptr<Structure const> _shared_prim,
      SymGroup const &_generating_group, SymCompareType const &_sym_compare,
      SiteFilterFunction _site_filter,
      std::vector<ClusterFilterFunction> _cluster_filter,
      std::vector<CandidateSitesFunction> _candidate_sites,
      std::vector<IntegralClusterOrbitGenerator> _custom_generators);

  /// The prim
  std::shared_ptr<Structure const> shared_prim;

  /// The orbit generating group
  SymGroup generating_group;

  /// The comparisons used for orbit generation
  SymCompareType sym_compare;

  /// A filter which excludes sites that are part of the neighborhood from being
  /// included in orbits. If `site_filter(site)==true`, then the site is
  /// included, else excluded.
  SiteFilterFunction site_filter;

  /// For each orbit branch, a function implementing 'bool filter(ClusterType)',
  /// which returns false for clusters that should not be used to construct an
  /// Orbit (i.e. pair distance too large). The null orbit filter,
  /// cluster_filter[0], is ignored.
  std::vector<ClusterFilterFunction> cluster_filter;

  /// For each orbit branch, a function that generates
  /// `std::vector<xtal::UnitCellCoord>`, a vector of all the sites which will
  /// be considered for inclusion in the orbit branch. The null orbit function,
  /// candidate_sites[0], is ignored but must be present.
  std::vector<CandidateSitesFunction> candidate_sites;

  /// Specifies particular clusters that should be used to generate orbits.
  std::vector<IntegralClusterOrbitGenerator> custom_generators;

 private:
  std::string m_method_name;

  std::string _name() const override;
  CLUSTER_PERIODICITY_TYPE _periodicity_type() const override;

  PeriodicOrbitVec _make_periodic_orbits(
      IntegralClusterVec const &generating_elements) const override;
  PeriodicOrbitVec _make_periodic_orbits(std::ostream &status) const override;
};

/// Parameters for the most generic orbit generation method currently
/// implemented
class GenericLocalClusterSpecs : public ClusterSpecs {
  CLONEABLE(GenericLocalClusterSpecs)

  typedef LocalSymCompare<IntegralCluster> SymCompareType;

  GenericLocalClusterSpecs(
      std::string _method_name, std::shared_ptr<Structure const> _shared_prim,
      SymGroup const &_generating_group, SymCompareType const &_sym_compare,
      SiteFilterFunction _site_filter,
      std::vector<ClusterFilterFunction> _cluster_filter,
      std::vector<CandidateSitesFunction> _candidate_sites,
      std::vector<IntegralClusterOrbitGenerator> _custom_generators);

  /// The prim
  std::shared_ptr<Structure const> shared_prim;

  /// The orbit generating group
  SymGroup generating_group;

  /// The comparisons used for orbit generation
  SymCompareType sym_compare;

  /// A filter which excludes sites that are part of the local neighborhood from
  /// being included in orbits. If `site_filter(site)==true`, then the site is
  /// included, else excluded.
  SiteFilterFunction site_filter;

  /// For each orbit branch, a function implementing 'bool filter(ClusterType)',
  /// which returns false for clusters that should not be used to construct an
  /// Orbit (i.e. pair distance too large). The null orbit filter,
  /// cluster_filter[0], is ignored.
  std::vector<ClusterFilterFunction> cluster_filter;

  /// For each orbit branch, a function that generates
  /// `std::vector<xtal::UnitCellCoord>`, a vector of all the sites which will
  /// be considered for inclusion in the orbit branch. The null orbit function,
  /// candidate_sites[0], is ignored but must be present.
  std::vector<CandidateSitesFunction> candidate_sites;

  /// Specifies particular clusters that should be used to generate orbits.
  std::vector<IntegralClusterOrbitGenerator> custom_generators;

 private:
  std::string m_method_name;

  std::string _name() const override;
  CLUSTER_PERIODICITY_TYPE _periodicity_type() const override;

  LocalOrbitVec _make_local_orbits(
      IntegralClusterVec const &generating_elements) const override;
  LocalOrbitVec _make_local_orbits(std::ostream &status) const override;
};

// ** Filter functions **

/// \brief Generate clusters using all Site
bool all_sites_filter(const xtal::Site &site);

/// \brief Generate clusters using Site with site_occupant.size() > 1
bool alloy_sites_filter(const xtal::Site &site);

/// \brief Generate clusters using Site with specified DoF
SiteFilterFunction dof_sites_filter(const std::vector<DoFKey> &dofs = {});

/// Accept all clusters
ClusterFilterFunction all_clusters_filter();

/// Accept clusters with max pair distance less than max_length
ClusterFilterFunction max_length_cluster_filter(double max_length);

// /// Accept clusters with max pair distance (using closest images) less than
// max_length ClusterFilterFunction within_scel_max_length_cluster_filter(
//   double max_length,
//   Eigen::Matrix3l const &superlattice_matrix);

/// No sites (for null orbit, or global dof only)
CandidateSitesFunction empty_neighborhood();

/// Only sites in the origin unit cell {b, 0, 0, 0}
CandidateSitesFunction origin_neighborhood();

// /// Sites in the supercell defined by the superlattice_matrix
// CandidateSitesFunction scel_neighborhood(Eigen::Matrix3l const
// &superlattice_matrix);

/// Sites within max_length distance to any site in the origin unit cell {b, 0,
/// 0, 0}
CandidateSitesFunction max_length_neighborhood(double max_length);

/// Sites within cutoff_radius distance to any site in the phenomenal cluster
CandidateSitesFunction cutoff_radius_neighborhood(
    IntegralCluster const &phenomenal, double cutoff_radius,
    bool include_phenomenal_sites = false);

// /// Sites within cutoff_radius distance (using closest images) to any site in
// the phenomenal cluster CandidateSitesFunction
// within_scel_cutoff_radius_neighborhood(
//   IntegralCluster const &phenomenal,
//   double cutoff_radius,
//   Eigen::Matrix3l const &superlattice_matrix);

}  // namespace CASM
#endif
