#ifndef CASM_enum_enumerate_configurations_impl
#define CASM_enum_enumerate_configurations_impl

#include "casm/app/enum/EnumInterface.hh"
#include "casm/app/enum/enumerate_configurations.hh"
#include "casm/casm_io/dataformatter/FormattedDataFile_impl.hh"
#include "casm/clex/Supercell_impl.hh"
#include "casm/clex/Configuration_impl.hh"
#include "casm/database/ScelDatabase.hh"
#include "casm/database/ConfigDatabase.hh"
#include "casm/database/ConfigDatabaseTools_impl.hh"

namespace CASM {

  /// Enumerate configurations
  ///
  /// This method enumerates configurations given a rage of starting values, typically a range
  /// of supercells or initial configurations, possibly with particular sites selected for
  /// enumeration, represented using `ConfigEnumInput`.
  ///
  /// A pseudo-code outline of the method is:
  /// \code
  /// for name_value_pair in range [name_value_pairs_begin, name_value_pairs_end):
  ///   print "Enumerate configuration for " + name_value_pair.first + "..."
  ///   auto enumerator = make_enumerator_f(name_value_pair.first, name_value_pair.second);
  ///   for configuration generated by enumerator:
  ///     make ConfigEnumDataType data
  ///     if options.filter and !options.filter(configuration):
  ///       do not insert configuration
  ///     else
  ///       if is_guaranteed_for_database_insert(enumerator):
  ///         insert configuration in configuration_db
  ///       else:
  ///         make primitive canonical configuration and insert in configuration_db
  ///         if !options.primitive_only:
  ///           make non-primitive canonical configuration and insert in configuration_db
  ///     if options.output_enumerated_configurations:
  ///       formatter(data)
  /// if !options.dry_run:
  ///   commit supercell_db
  ///   commit configuration_db
  ///   if options.output_enumerated_configurations:
  ///     write formatted data to options.output_path
  /// \endcode
  ///
  /// Note:
  /// - To avoid unnecessary configuration canonicalization, specialize the following method:
  ///   `template<> bool is_guaranteed_for_database_insert(EnumeratorType const &);`
  ///
  /// \param primclex PrimClex provides access to project database and other data
  /// \param options See ConfigEnumOptions for method options
  /// \param make_enumerator_f A function that constructs a Configuration enumerator of type
  ///        EnumeratorType for each value in the range `[name_value_pairs_begin, name_value_pairs_end)`.
  ///        Requires signature:
  ///            EnumeratorType make_enumerator_f(Index initial_state_index,
  ///                                             std::string initial_state_name,
  ///                                             InitialStateType const &initial_state);
  /// \param name_value_pairs_begin, name_value_pairs_end A range of pairs of name (for printing
  ///        progress) to `InitialStateType` value (typically, but not necessarily
  ///        `InputType = ConfigEnumInput`). The value `InputType` is used as the argument to
  ///        `make_enumerator_f` to construct a series of enumerators which are executed in turn.
  /// \param formatter DataFormatter used to record enumerated configurations. See ConfigEnumOptions
  ///        for output options. The ConfigEnumDataType should follow the example of `ConfigEnumData`
  ///        which provides the minimum required interface.
  ///
  /// Note:
  /// - Uses CASM::log() for logging progress
  ///
  template <
    typename MakeEnumeratorFunction,
    typename InputNameValuePairIterator,
    typename ConfigEnumDataType >
  void enumerate_configurations(
    PrimClex const &primclex,
    ConfigEnumOptions const &options,
    MakeEnumeratorFunction make_enumerator_f,
    InputNameValuePairIterator name_value_pairs_begin,
    InputNameValuePairIterator name_value_pairs_end,
    DataFormatter<ConfigEnumDataType> const &formatter) {

    Log &log = CASM::log();
    std::pair<DB::Database<Configuration>::iterator, bool> insert_result;
    std::string dry_run_msg = CASM::dry_run_msg(options.dry_run);

    auto &supercell_db = primclex.db<Supercell>();
    auto &configuration_db = primclex.db<Configuration>();

    Index Ninit = configuration_db.size();
    log.subsection().begin_section<Log::standard>();
    log << dry_run_msg << "# configurations in this project: " << Ninit << "\n" << std::endl;
    log << dry_run_msg << "Begin enumeration" << std::endl;

    typedef FormattedDataFile<ConfigEnumDataType> FormattedDataFileType;
    std::unique_ptr<FormattedDataFileType> data_out_ptr;
    if(options.output_configurations) {
      data_out_ptr = notstd::make_unique<FormattedDataFileType>(options.output_options);
    }

    Index initial_state_index {0};
    auto it = name_value_pairs_begin;
    for(; it != name_value_pairs_end; ++it) {
      auto const &input_name_value_pair = *it;

      Index count = 0;
      Index count_filtered = 0;
      Index num_before = configuration_db.size();
      log << dry_run_msg << "Enumerate configurations for: " << input_name_value_pair.first << std::endl;
      auto enumerator = make_enumerator_f(initial_state_index, input_name_value_pair.first, input_name_value_pair.second);

      for(Configuration const &configuration : enumerator) {

        ConfigEnumDataType data {
          primclex,
          initial_state_index,
          input_name_value_pair.first,
          input_name_value_pair.second,
          enumerator,
          configuration};

        /// Use while transitioning Supercell to no longer need a `PrimClex const *`
        if(!configuration.supercell().has_primclex()) {
          configuration.supercell().set_primclex(options.primclex_ptr);
        }

        ++count;
        if(options.filter && !options.filter(configuration)) {
          data.is_excluded_by_filter = true;
        }
        else {
          // checks `is_guaranteed_for_database_insert(enumerator)` to see if configuration
          // can be directly inserted, else makes canonical before inserting
          data.insert_result = make_canonical_and_insert(
                                 enumerator,
                                 configuration,
                                 supercell_db,
                                 configuration_db,
                                 options.primitive_only);
        }

        if(data_out_ptr && (options.output_filtered_configurations || !data.is_excluded_by_filter)) {
          (*data_out_ptr)(formatter, data);
        }
      }

      Index num_after = configuration_db.size();
      log << dry_run_msg << count << " configurations"
          << " (" << (num_after - num_before) << " new, "
          << count_filtered << " excluded by filter)." << std::endl << std::endl;

      initial_state_index++;
    }
    log << dry_run_msg << "Enumeration complete" << std::endl << std::endl;

    Index Nfinal = configuration_db.size();
    log << dry_run_msg << "# new configurations: " << Nfinal - Ninit << "\n";
    log << dry_run_msg << "# configurations in this project: " << Nfinal << "\n" << std::endl;

    if(!options.dry_run) {
      log << "Write supercell database... " << std::flush;
      supercell_db.commit();
      log << "DONE" << std::endl;

      log << "Write configuration database... " << std::flush;
      configuration_db.commit();
      log << "DONE" << std::endl;
    }
    if(data_out_ptr) {
      log << "Write enumerated configurations: " << options.output_options.file_path << std::endl;
      data_out_ptr.reset();
    }
    log.end_section();
  }

}

#endif
