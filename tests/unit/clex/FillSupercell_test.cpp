#include "Common.hh"
#include "FCCTernaryProj.hh"
#include "casm/app/AppIO.hh"
#include "casm/clex/Configuration_impl.hh"
#include "casm/clex/FillSupercell_impl.hh"
#include "casm/crystallography/Niggli.hh"
#include "casm/crystallography/Structure.hh"
#include "casm/database/ConfigDatabase.hh"
#include "casm/database/ScelDatabaseTools.hh"
#include "crystallography/TestStructures.hh"
#include "gtest/gtest.h"

using namespace CASM;

TEST(FillSupercellTest, Test1) {
  // test Configuration::generate_name_impl
  ScopedNullLogging logging;
  test::FCCTernaryProj proj;
  proj.check_init();
  PrimClex primclex{proj.dir};
  auto shared_prim = primclex.shared_prim();
  auto &supercell_db = primclex.db<Supercell>();

  Supercell const &canon_scel =
      *make_canonical_and_insert(shared_prim, shared_prim->lattice(),
                                 supercell_db)
           .first;

  Configuration config{canon_scel};
  Configuration canon_scel_config = fill_supercell(config, canon_scel);
  EXPECT_EQ(config, canon_scel_config);
}

TEST(FillSupercellTest, Test2) {
  // test Configuration::generate_name_impl
  ScopedNullLogging logging;
  test::FCCTernaryProj proj;
  proj.check_init();
  PrimClex primclex{proj.dir};
  auto shared_prim = primclex.shared_prim();
  auto &supercell_db = primclex.db<Supercell>();

  Eigen::Matrix3l T;
  T << 2, 0, 0, 0, 2, 0, 0, 0, 2;
  Lattice superlattice = make_superlattice(shared_prim->lattice(), T);

  Supercell const &canon_scel =
      *make_canonical_and_insert(shared_prim, superlattice, supercell_db).first;

  Configuration config{canon_scel};
  Configuration canon_scel_config = fill_supercell(config, canon_scel);
}

Eigen::Matrix3l _fcc_conventional_transf_mat() {
  Eigen::Matrix3l transf_mat;
  transf_mat << -1, 1, 1, 1, -1, 1, 1, 1, -1;
  return transf_mat;
}

TEST(FillSupercellTest, MakeAllSuperConfigurationsTest1) {
  // test `make_all_super_configurations`
  //
  // If a supercell's factor group is smaller than the prim factor group,
  // permutations may not generate all equivalent infinite orderings. This tests
  // the `make_all_super_configurations` function which generates all equivalent
  // orderings in a supercell given a particular configuration by finding all
  // non-equivalent orderings with respect to the supercell factor group and
  // then for each of those using permutations to generate equivalents.

  // The test example is a conventional FCC unit cell with 2 "A" sites and 2 "B"
  // sites, for which there are 6 equivalent orderings. In the 1x1x2 supercell
  // of the conventional FCC unit cell the 'a' and 'c' lattice vectors are not
  // equivalent so depending on the initial ordering only 4 or 2 equivalent
  // orderings can be generated by permutations. With the
  // `make_all_super_configurations` function all 6 equivalent infinite
  // orderings are generated.

  auto shared_prim =
      std::make_shared<Structure const>(test::FCC_ternary_prim());

  // conventional FCC unit cell (4 sites)
  auto shared_supercell_small = std::make_shared<Supercell const>(
      shared_prim, _fcc_conventional_transf_mat());

  // 1x1x2 supercell of conventional FCC unit cell
  Eigen::Matrix3l T;
  T << 1, 0, 0, 0, 1, 0, 0, 0, 2;
  auto shared_supercell_large = std::make_shared<Supercell const>(
      shared_prim, _fcc_conventional_transf_mat() * T);

  // generate A2B2 orderings in conventional FCC unit cell
  for (int i = 0; i < shared_supercell_small->num_sites(); ++i) {
    for (int j = i + 1; j < shared_supercell_small->num_sites(); ++j) {
      Configuration small_configuration{shared_supercell_small};

      // default initializes with all 4 occupations == 0
      EXPECT_EQ(small_configuration.size(), 4);
      for (int l = 0; l < small_configuration.size(); ++l) {
        EXPECT_EQ(small_configuration.occ(l), 0);
      }

      small_configuration.set_occ(i, 1);
      small_configuration.set_occ(j, 1);

      {
        // always 6 equivs by permutation in conventional FCC unit cell

        // ConfigEnumByPermutation generates all equivalents possible by
        // permutation
        ConfigEnumByPermutation enum_permutation{small_configuration};
        std::vector<Configuration> equivs{enum_permutation.begin(),
                                          enum_permutation.end()};
        EXPECT_EQ(equivs.size(), 6);
      }

      {
        // depending on the initial ordering, may be 4 or 2 equivs by
        // permutation in the 1x1x2 supercell

        // 2 equivalents by permutation if ordered in layers perpendicular to
        // 'c', 4 otherwise

        // fill the "small_configuration" into the 1x1x2 supercell
        Configuration filled_config =
            fill_supercell(small_configuration, shared_supercell_large);

        // ConfigEnumByPermutation generates all equivalents possible by
        // permutation
        ConfigEnumByPermutation enum_permutation{filled_config};
        std::vector<Configuration> equivs{enum_permutation.begin(),
                                          enum_permutation.end()};
        EXPECT_TRUE((equivs.size() == 4) || (equivs.size() == 2));
      }

      {
        // `make_all_super_configurations` finds all 6 equivalent infinite
        // orderings (with respect to the prim factor group) in the 1x1x2
        // supercell

        std::vector<Configuration> equivs;
        make_all_super_configurations(small_configuration,
                                      shared_supercell_large,
                                      std::back_inserter(equivs));
        EXPECT_EQ(equivs.size(), 6);
      }
    }
  }
}
