#include "casm/crystallography/Lattice.hh"
#include "casm/crystallography/LatticeIsEquivalent.hh"
#include "casm/crystallography/SymTools.hh"
#include "casm/misc/CASM_Eigen_math.hh"  // for almost_equal of Eigen types
#include "gtest/gtest.h"

TEST(ExampleCrystallographyLattice, LatticeIsEquivalent) {
  // Two lattices are equivalent if the lattice vectors generate equivalent
  // lattice points, even
  //   if the lattice vectors themselves are different.
  //
  // For example, replacing one lattice vector, a, with the combination a+b,
  // results in skewed
  //   lattice vectors, but all the lattice points generated by combinations of
  //   the lattice vectors
  //    remain unchanged.
  //
  // The lattice points generated by a given lattice, with column vector matrix
  // A, are all the
  //   the points, r = A * x, where x is an integer vector.
  //
  // For another lattice, with column vector matrix B, to generate the same set
  // of points, it must
  //   be the case that for every x there exists an integer vector y such that A
  //   * x = B * y.
  //
  // Therefore, two lattices, with column vector matrices A and B, are
  // equivalent if there exists
  //   a unimodular matrix, U, (integer matrix with determinant equal to 1) such
  //   that: B = A * U.

  // The class LatticeIsEquivalent can be used to do such checks and get the U
  // matrix.

  // A cubic lattice (a, b, c)
  Eigen::Vector3d a{1.0, 0.0, 0.0};
  Eigen::Vector3d b{0.0, 1.0, 0.0};
  Eigen::Vector3d c{0.0, 0.0, 1.0};
  CASM::xtal::Lattice lattice_A{a, b, c};

  // An equivalent lattice (a+b, b, c)
  CASM::xtal::Lattice lattice_B{a + b, b, c};

  // Functor to check if lattice_B is equivalent to other lattices:
  CASM::xtal::LatticeIsEquivalent B_is_equivalent_to{lattice_B};
  EXPECT_TRUE(B_is_equivalent_to(lattice_A, CASM::TOL));

  Eigen::Matrix3i check_U;
  check_U << 1, 0, 0, 1, 1, 0, 0, 0, 1;
  // the LatticeIsEquivalent::U provides the U value calculated such that
  // lattice_B = lattice_A * U
  EXPECT_TRUE(almost_equal(B_is_equivalent_to.U(), check_U.cast<double>()));

  // The method xtal::is_equivalent uses LatticeIsEquivalent internally and can
  // be used if only
  //   the equivalence check is needed and not U.
  EXPECT_TRUE(CASM::xtal::is_equivalent(lattice_B, lattice_A));
}

TEST(ExampleCrystallographyLattice, LatticePointGroup) {
  // The point group of the lattice is the set of orthogonal transformations, S,
  // that result in an
  //   equivalent lattice: S * L = L * U, where S is orthogonal, U is
  //   unimodular, L is the lattice column vector matrix.
  //
  // When this criteria is satisfied, U = L.inv * S * L, is a transformation of
  // fractional coordinates:
  //
  //   (1) r_cart' = S * r_cart, S is an orthogonal Cartesian transformation
  //   (2) r_cart = L * r_frac, Cartesian and fractional coordinates are related
  //   via L L * r_frac' = S * L * r_frac r_frac' = L.inv * S * L * r_frac
  //   r_frac' = U * r_frac
  //
  // CASM finds the lattice point group by iterating over all unimodular
  // matrices, which are
  //   straightforward to enumerate, and checking if S = L * U * L.inv is
  //   orthogonal. The specific numerically robust criteria CASM uses assumes
  //   that symmetry is not perfect, with "deformation" F such that S * L = F *
  //   L * U, calculates the Green-Lagrange strain, E_GL, from F, and thens
  //   check if E_GL * E_GL.transpose is sufficiently close to zero. In other
  //   words, if the transformation results in zero strain to the lattice
  //   vectors, then the transformation S is orthogonal.
  //
  // CASM has two SymOp classes:
  // - CASM::xtal::SymOp: Applies to CASM::xtal objects. A simplified data
  // structure to hold
  //   transformation data, it has:
  //   - a Cartesian transformation matrix,
  //   - a Cartesian translation vector
  //   - a boolean value to indicate time reversal symmetry
  // - CASM::SymOp: A class that enables linking to alternative representations
  // (SymOpRep)
  //   to apply transformations to objects that are not simply represented by
  //   Cartesian coordinates. More info on this class is given in later
  //   examples.
  //
  // By convention, CASM implements two functions to apply SymOp transformations
  // to CASM objects:
  // - CASM::sym::apply applies a SymOp transformation to a CASM object,
  // transforming it
  // - CASM::sym::copy_apply makes a copy of the object and transforms the copy

  // A cubic lattice with lattice vector column matrix == I
  CASM::xtal::Lattice lattice{Eigen::Matrix3d::Identity()};

  // Construct the lattice point group
  std::vector<CASM::xtal::SymOp> point_group =
      CASM::xtal::make_point_group(lattice);

  // The cubic point group has 48 elements
  EXPECT_EQ(point_group.size(), 48);

  // By definition, applying an operation in the point group results in an
  // equivalent lattice
  for (auto const &sym_op : point_group) {
    // For point group operations, there is no translation
    EXPECT_TRUE(almost_equal(sym_op.translation, Eigen::Vector3d::Zero()));

    // Apply the transformation matrix sym_op.matrix to the lattice vectors via
    // CASM::sym::apply
    {
      // CASM::sym::apply applies a SymOp to a CASM object
      // For Lattice, this is equivalent to sym_op.matrix *
      // lattice.lat_column_mat()
      CASM::xtal::Lattice tmp_lattice{lattice};
      CASM::sym::apply(sym_op, tmp_lattice);
      EXPECT_TRUE(almost_equal(tmp_lattice.lat_column_mat(),
                               sym_op.matrix * lattice.lat_column_mat()));
      EXPECT_TRUE(CASM::xtal::is_equivalent(tmp_lattice, lattice));
    }

    // Alternatively, CASM::sym::copy_apply makes a copy of the object and
    // transforms it in one step
    EXPECT_TRUE(CASM::xtal::is_equivalent(
        CASM::sym::copy_apply(sym_op, lattice), lattice));
  }
}
