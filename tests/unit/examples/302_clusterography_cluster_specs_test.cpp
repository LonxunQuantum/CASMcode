#include "gtest/gtest.h"

#include "casm/app/AppIO_impl.hh"
#include "casm/casm_io/Log.hh"
#include "casm/clusterography/ClusterOrbits_impl.hh"
#include "casm/clusterography/ClusterSpecs_impl.hh"

#include "crystallography/TestStructures.hh" // for test::ZrO_prim

// While CASM provides a specific function for generating the asymmetric unit, it also provides
//   methods to generate clusters in more general cases using:
//   - the OrbitBranchSpecs class
//   - the IntegralClusterOrbitGenerator class
//   - classes derived from the ClusterSpecs class
//
// The standard CASM cluster generation methods work recursively, meaning 2-point clusters are
//   generated by attempting to add sites to 1-point clusters, 3-point clusters are generated by
//   attempting to add sites to 2-point clusters, etc.
//
// The "orbit tree" of all clusters is made up of "orbit branches" where each "branch" of the
//   "orbit tree" is made up of all clusters with the same number of sites. For example, the n=2
//   "orbit branch" consists of all orbits of 2-point clusters, the n=3 "orbit branch" consists
//   of all orbits of 3-point clusters, etc.
//
// The OrbitBranchSpecs class specifies how one orbit branch should be constructed, given the
//   previous branch as input. OrbitBranchSpecs has:
//   - A pointer to the prim Structure
//   - A pointer to the generating group
//   - A "SymCompare" functor
//   - A vector of "candidate sites": UnitCellCoord indicating sites that should be added to
//     to clusters from the previous branch in an attempt to find new unique clusters
//   - A filter function (std::function<bool (ClusterType)>) which returns false for clusters that
//     should not be used to construct an Orbit. This can be used to specify truncation criteria
//     for orbits in a branch. The most common criteria is a site-to-site distance cutoff.
//
// Sometimes it is known or suspected that a particular cluster orbit is necessary to include in the
//   cluster expansion basis, perhaps due to a known ground state ordering. The
//   IntegralClusterOrbitGenerator class provides a way to specify that particular cluster orbits
//   and subcluster orbits be generated. It consists of:
//   - an IntegralCluster prototype
//   - a bool "include_subclusters" option, which if true tells the orbit generating method to also
//     generate all orbits that are subclusters of the prototype cluster. For example, if prototype
//     is a triplet cluster, each pair of sites in the triplet would be used to generate pair
//     cluster orbits, and each single site in the triplet would be used to generate single point
//     cluster orbits.
//
// The classes derived from the ClusterSpecs class specify how to construct all the orbit branches.
//   They provide:
//   - A method to generate all orbits, as determined by implementation-specific parameters
//   - A method to generate orbits given a vector of generating elements
//
//   Depending on the particular method being implemented, they will typically do this by
//   specifying how many orbit branches to construct and how to generate an OrbitBranchSpecs
//   instance for each branch by providing:
//   - A pointer to the prim Structure
//   - A pointer to the generating group
//   - A "SymCompare" functor
//   - A method to generate "candidate sites" for each orbit branch
//   - A method to generate a cluster filter function for each orbit branch
//   - A method to specify custom clusters, as with a vector of IntegralClusterOrbitGenerator.
//
// CASM provides some functions that can help build the "Specs" classes:
// - SiteFilterFunction (typedef std::function<bool (xtal::Site)>):
//   - all_sites_filter: Generate clusters using all Sites
//   - alloy_sites_filter: Generate clusters using Site with site_occupant.size() > 1
//   - dof_sites_filter(const std::vector<DoFKey> &dofs = {}): Generate clusters using Site with
//     specified DoF
// - ClusterFilterFunction (typedef std::function<bool (IntegralCluster)>):
//   - all_clusters_filter(): Accept all clusters
//   - max_length_cluster_filter(double max_length): Accept clusters with max pair distance less
//     than max_length
//   - within_scel_max_length_cluster_filter(double max_length, Eigen::Matrix3l const &
//     superlattice_matrix): Accept clusters with max pair distance (using closest images) less than
//     max_length
// - CandidateSitesFunction:
//   (typedef std::function<std::vector<xtal::UnitCellCoord> (Structure const &, SiteFilterFunction)>)
//   - empty_neighborhood(): No sites (for null orbit, or global dof only)
//   - origin_neighborhood(): Only sites in the origin unit cell
//   - scel_neighborhood(Eigen::Matrix3l const &superlattice_matrix): All Sites in the supercell
//     defined by the superlattice_matrix
//   - max_length_neighborhood(double max_length): Sites within max_length distance to any site in
//     the origin unit cell.
//   - cutoff_radius_neighborhood(IntegralCluster const &phenomenal, double cutoff_radius): Sites
//     within cutoff_radius distance to any site in the phenomenal cluster
//   - within_scel_cutoff_radius_neighborhood(IntegralCluster const &phenomenal,
//     double cutoff_radius, Eigen::Matrix3l const &superlattice_matrix): Sites within cutoff_radius
//     distance (using closest images) to any site in the phenomenal cluster


TEST(ExampleClusterographyClusterOrbits, OrbitBranchSpecs) {

  // An example using OrbitBranchSpecs and the `make_orbits` function directly
  //   to generate n=0, n=1, and n=2 branches, along with custom n=3 orbits

  // Construct a ZrO prim (same as above)
  auto shared_prim = std::make_shared<CASM::Structure const>(test::ZrO_prim());

  typedef PrimPeriodicSymCompare<IntegralCluster> sym_compare_type;
  typedef Orbit<sym_compare_type> orbit_type;

  // Use the complete factor group as the generating group
  SymGroup const &generating_group = shared_prim->factor_group();

  // Use a PrimPeriodicSymCompare<IntegralCluster> "SymCompare" functor:
  sym_compare_type sym_compare {shared_prim, shared_prim->lattice().tol()};

  // Include only sites with > 1 allowed occupant
  SiteFilterFunction site_filter = alloy_sites_filter;

  // A vector that will be filled with candidate sites for constructing clusters
  std::vector<xtal::UnitCellCoord> candidate_sites;

  // Will hold a function to generate candidate sites
  //   typedef std::function<std::vector<xtal::UnitCellCoord> (Structure const &, SiteFilterFunction)>
  CandidateSitesFunction candidate_sites_f;

  // Will hold a function to filter candidate clusters
  //   typedef std::function<std::vector<xtal::UnitCellCoord> (Structure const &, SiteFilterFunction)>
  ClusterFilterFunction cluster_filter;


  // A vector of OrbitBranchSpecs for our orbit_type
  std::vector<OrbitBranchSpecs<orbit_type> > specs;

  // --- Construct n=0 OrbitBranchSpecs ---
  candidate_sites_f = empty_neighborhood();
  cluster_filter = all_clusters_filter();

  candidate_sites = candidate_sites_f(*shared_prim, site_filter);
  specs.emplace_back(*shared_prim, candidate_sites.begin(), candidate_sites.end(), generating_group,
                     cluster_filter, sym_compare);

  // --- Construct n=1 OrbitBranchSpecs ---
  candidate_sites_f = origin_neighborhood();
  cluster_filter = all_clusters_filter();

  candidate_sites = candidate_sites_f(*shared_prim, site_filter);
  specs.emplace_back(*shared_prim, candidate_sites.begin(), candidate_sites.end(), generating_group,
                     cluster_filter, sym_compare);

  // --- Construct n=2 OrbitBranchSpecs, using pairs with max_length<5.0 ---
  double max_length = 5.17;
  candidate_sites_f = max_length_neighborhood(max_length);
  cluster_filter = max_length_cluster_filter(max_length);

  candidate_sites = candidate_sites_f(*shared_prim, site_filter);
  specs.emplace_back(*shared_prim, candidate_sites.begin(), candidate_sites.end(), generating_group,
                     cluster_filter, sym_compare);

  // --- Custom cluster orbit generators for triplet clusters ---
  IntegralCluster triplet_cluster {*shared_prim};
  bool include_subclusters = true;
  std::vector<IntegralClusterOrbitGenerator> custom_generators;

  // triplet cluster made of [a, 0, 0], [a, a, 0]
  triplet_cluster.elements().clear();
  triplet_cluster.elements().emplace_back(2, 0, 0, 0);
  triplet_cluster.elements().emplace_back(2, 1, 0, 0);
  triplet_cluster.elements().emplace_back(2, 1, 1, 0);
  custom_generators.emplace_back(triplet_cluster, include_subclusters);

  // triplet cluster made of [a, 0, 0], [0, 0, c/2]
  triplet_cluster.elements().clear();
  triplet_cluster.elements().emplace_back(2, 0, 0, 0);
  triplet_cluster.elements().emplace_back(3, 0, 0, 0);
  triplet_cluster.elements().emplace_back(2, 1, 0, 0);
  custom_generators.emplace_back(triplet_cluster, include_subclusters);

  // --- Make orbits using OrbitBranchSpecs and custom generators

  // Store generated orbits in this container
  std::vector<orbit_type> orbits;

  // Print messages about orbit generation progress to `status` stream, in this case do not print.
  std::ostream &status = CASM::null_log();

  // Construct orbits
  make_orbits(specs.begin(), specs.end(), custom_generators, std::back_inserter(orbits), status);

  // To print results:
  // #include "casm/app/AppIO_impl.hh"
  OrbitPrinterOptions printer_options;
  printer_options.coord_type = CASM::INTEGRAL;
  ProtoSitesPrinter printer {printer_options};
  print_clust(orbits.begin(), orbits.end(), CASM::log(), printer);

  // Expected orbits: (TODO: more precise check of orbits)
  EXPECT_EQ(orbits.size(), 8);

  EXPECT_EQ(orbits[0].size(), 1); // null orbit
  EXPECT_EQ(orbits[0].prototype().size(), 0);

  EXPECT_EQ(orbits[1].size(), 2); // [Va,O] site orbit
  EXPECT_EQ(orbits[1].prototype().size(), 1);

  EXPECT_EQ(orbits[2].size(), 2); // 2NN pair [0, 0, c/2]
  EXPECT_EQ(orbits[2].prototype().size(), 2);

  EXPECT_EQ(orbits[3].size(), 6); // 1NN pair [a, 0, 0]
  EXPECT_EQ(orbits[3].prototype().size(), 2);

  EXPECT_EQ(orbits[4].size(), 12); // 3NN pair [a, a, c/2]
  EXPECT_EQ(orbits[4].prototype().size(), 2);

  EXPECT_EQ(orbits[5].size(), 2); // 4NN pair [0, 0, c]
  EXPECT_EQ(orbits[5].prototype().size(), 2);

  EXPECT_EQ(orbits[6].size(), 4); // triplet cluster [a, 0, 0], [a, a, 0]
  EXPECT_EQ(orbits[6].prototype().size(), 3);

  EXPECT_EQ(orbits[7].size(), 24); // triplet cluster [a, 0, 0], [0, 0, c/2]
  EXPECT_EQ(orbits[7].prototype().size(), 3);
}
