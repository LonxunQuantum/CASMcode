#include "gtest/gtest.h"
#include "autotools.hh"
#include "casm/casm_io/container/json_io.hh"
#include "casm/clex/FillSupercell.hh"
#include "casm/clex/Supercell.hh"
#include "casm/clusterography/ClusterSpecs_impl.hh"
#include "casm/crystallography/Structure.hh"
#include "casm/enumerator/ClusterSitesSelector_impl.hh"
#include "casm/enumerator/ConfigEnumInput.hh"
#include "crystallography/TestStructures.hh"

using namespace CASM;
using namespace test;

// helper functions
namespace {

  /// Make transformation_matrix_to_super for conventional 4 atom FCC cell, from the 1 atom primitive
  Eigen::Matrix3i _fcc_conventional_transf_mat();

  /// Make L12 (A3B1), in conventional 4 atom FCC cell
  Configuration _make_configuration_L12(std::shared_ptr<CASM::Structure const> shared_prim);

  /// 3x3x3 super configuration of configuration_L12
  Configuration _make_configuration_L12_3x3x3(Configuration const &_configuration_L12);

  /// Check how many ConfigEnumInput have a matching number of each type of occupant on the selected sites
  Index count_selected(std::vector<ConfigEnumInput> const &with_cluster_sites, std::vector<Index> expected_occ_count);

}

class ClusterSitesSelectorTest : public testing::Test {
protected:

  std::shared_ptr<CASM::Structure const> shared_prim;
  Configuration configuration_L12;        // L12 (A3B1), in conventional 4 atom FCC cell
  Configuration configuration_L12_3x3x3;  // 3x3x3 superconfiguration of configuration_L12

  ClusterSitesSelectorTest():
    shared_prim(std::make_shared<CASM::Structure const>(test::FCC_ternary_prim())),
    configuration_L12(_make_configuration_L12(shared_prim)),
    configuration_L12_3x3x3(_make_configuration_L12_3x3x3(configuration_L12)) {
    EXPECT_EQ(configuration_L12.size(), 4);
    EXPECT_EQ(configuration_L12_3x3x3.size(), 108);
  }

};

TEST_F(ClusterSitesSelectorTest, Test1) {

  // Example, generating Configuration with unique cluster sites selected:
  // (starting from "periodic_max_length" clusters)
  // - L12 (A3B1) in conventional FCC supercell (4 atoms)

  ConfigEnumInput reference_config_enum_input {configuration_L12_3x3x3, {}};

  double a = configuration_L12.supercell().lattice()[0].norm();
  std::vector<double> max_length {
    0, // null cluster
    0, // point clusters
    3 * a * sqrt(3.) // a * sqrt(2.0) / 2.0 + TOL // 1NN pair clusters
  };

  PeriodicMaxLengthClusterSpecs cluster_specs {
    shared_prim,
    make_generating_group(reference_config_enum_input),
    alloy_sites_filter,
    max_length}; // max length, for point clusters only (null orbit branch, point orbit branch)

  // Create ConfigEnumInput that are copies of `reference_config_enum_input` with orbit prototype
  // sites selected, for all orbits generated by "cluster_specs"
  std::vector<ConfigEnumInput> with_cluster_sites = select_cluster_sites(
                                                      reference_config_enum_input,
                                                      cluster_specs);
  EXPECT_EQ(with_cluster_sites.size(), 5); // Expect 5 results
  EXPECT_EQ(count_selected(with_cluster_sites, {0, 0, 0}), 1); // expect 1 unselected
  EXPECT_EQ(count_selected(with_cluster_sites, {1, 0, 0}), 1); // expect 1 with 1 "A" site selected
  EXPECT_EQ(count_selected(with_cluster_sites, {0, 1, 0}), 1); // expect 1 with 1 "B" site selected
  EXPECT_EQ(count_selected(with_cluster_sites, {1, 1, 0}), 1); // expect 1 with 1 "A" and 1 "B" site selected
  EXPECT_EQ(count_selected(with_cluster_sites, {2, 0, 0}), 1); // expect 1 with 2 "A" site selected

}

TEST_F(ClusterSitesSelectorTest, Test2) {

  // Example, generating Configuration with unique cluster sites selected:
  // (starting from "within_scel" clusters)
  // - L12 (A3B1) in conventional FCC supercell (4 atoms)

  ConfigEnumInput reference_config_enum_input {configuration_L12_3x3x3, {}};

  double a = configuration_L12.supercell().lattice()[0].norm();
  std::vector<double> max_length {
    0, // null cluster
    0, // point clusters
    3 * a * sqrt(3.) // a * sqrt(2.0) / 2.0 + TOL // 1NN pair clusters
  };

  Supercell const &supercell = reference_config_enum_input.configuration().supercell();
  WithinScelMaxLengthClusterSpecs cluster_specs {
    shared_prim,
    supercell.sym_info().transformation_matrix_to_super(),
    make_generating_group(reference_config_enum_input),
    alloy_sites_filter,
    max_length};

  // Create ConfigEnumInput that are copies of `reference_config_enum_input` with orbit prototype
  // sites selected, for all orbits generated by "cluster_specs"
  std::vector<ConfigEnumInput> with_cluster_sites = select_cluster_sites(
                                                      reference_config_enum_input,
                                                      cluster_specs);

  EXPECT_EQ(with_cluster_sites.size(), 5); // Expect 3 results
  EXPECT_EQ(count_selected(with_cluster_sites, {0, 0, 0}), 1); // expect 1 unselected
  EXPECT_EQ(count_selected(with_cluster_sites, {1, 0, 0}), 1); // expect 1 with 1 "A" site selected
  EXPECT_EQ(count_selected(with_cluster_sites, {0, 1, 0}), 1); // expect 1 with 1 "B" site selected
  EXPECT_EQ(count_selected(with_cluster_sites, {1, 1, 0}), 1); // expect 1 with 1 "A" and 1 "B" site selected
  EXPECT_EQ(count_selected(with_cluster_sites, {2, 0, 0}), 1); // expect 1 with 2 "A" site selected

}

namespace {

  /// Make transformation_matrix_to_super for conventional 4 atom FCC cell, from the 1 atom primitive
  Eigen::Matrix3i _fcc_conventional_transf_mat() {
    Eigen::Matrix3i transf_mat;
    transf_mat << -1, 1, 1, 1, -1, 1, 1, 1, -1;
    return transf_mat;
  }

  /// Make L12 (A3B1), in conventional 4 atom FCC cell
  Configuration _make_configuration_L12(std::shared_ptr<CASM::Structure const> shared_prim) {
    auto conventional_fcc = std::make_shared<Supercell>(shared_prim, _fcc_conventional_transf_mat());
    Configuration configuration {conventional_fcc};
    configuration.configdof().occ(0) = 1;
    return configuration;
  }

  /// 3x3x3 super configuration of configuration_L12
  Configuration _make_configuration_L12_3x3x3(Configuration const &_configuration_L12) {
    auto conventional_fcc_3x3x3 = std::make_shared<Supercell>(
                                    _configuration_L12.supercell().shared_prim(),
                                    3 * _fcc_conventional_transf_mat());
    return fill_supercell(_configuration_L12, conventional_fcc_3x3x3);
  }

  /// Check how many ConfigEnumInput have a matching number of each type of occupant on the selected sites
  ///
  /// Example, FCC ternary prim:
  /// - Count how many ConfigEnumInput in `with_cluster_sites` have 1 site occupied by an A atom,
  ///   2 sites occupied by a B atom, and 0 sites occupied by a C atom selected:
  ///       `count_selected(with_cluster_sites, {1, 2, 0})`
  Index count_selected(std::vector<ConfigEnumInput> const &with_cluster_sites, std::vector<Index> expected_occ_count) {
    Index matching = 0;
    for(ConfigEnumInput const &config_with_cluster : with_cluster_sites) {
      Configuration const &config = config_with_cluster.configuration();
      std::vector<Index> occ_count(expected_occ_count.size(), 0);
      for(Index site_index : config_with_cluster.sites()) {
        occ_count[config.occ(site_index)]++;
      }
      if(occ_count == expected_occ_count) {
        matching++;
      }
    }
    return matching;
  }

}
