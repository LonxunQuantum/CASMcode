#include "gtest/gtest.h"
#include "autotools.hh"
#include "casm/clex/FillSupercell.hh"
#include "casm/clex/Supercell.hh"
#include "casm/crystallography/Structure.hh"
#include "casm/enumerator/ClusterSitesSelector_impl.hh"
#include "casm/enumerator/ConfigEnumInput.hh"
#include "crystallography/TestStructures.hh"

using namespace CASM;
using namespace test;

// helper functions
namespace {

  Eigen::Matrix3i _fcc_conventional_transf_mat();

  Configuration _make_configuration_L12(std::shared_ptr<CASM::Structure const> shared_prim);

  Configuration _make_configuration_L12_3x3x3(Configuration const &_configuration_L12);

  /// Check how many ConfigEnumInput have a matching number of each type of occupant on the selected sites
  Index count_selected(std::vector<ConfigEnumInput> const &with_cluster_sites, std::vector<Index> expected_occ_count) {

  }

  class ClusterSitesSelectorTest : public testing::Test {
  protected:

    std::shared_ptr<CASM::Structure const> shared_prim;
    Configuration configuration_L12;        // L12 (A3B1), in conventional 4 atom FCC cell
    Configuration configuration_L12_3x3x3;  // 3x3x3 superconfiguration of configuration_L12

    ClusterSitesSelectorTest():
      shared_prim(std::make_shared<CASM::Structure const>(test::FCC_ternary_prim())),
      configuration_L12(_make_configuration_L12(shared_prim)),
      configuration_L12_3x3x3(_make_configuration_L12_3x3x3(configuration_L12)) {
      EXPECT_EQ(configuration_L12.size(), 4);
      EXPECT_EQ(configuration_L12_3x3x3.size(), 108);
    }

  };

  TEST_F(ClusterSitesSelectorTest, Test1) {

    // Example, generating Configuration with unique cluster sites selected:
    // - L12 (A3B1) in conventional FCC supercell (4 atoms)
    // - Select null cluster orbit and unique point clusters

    PeriodicMaxLengthClusterSpecs cluster_specs {
      shared_prim,
      notstd::clone(shared_prim->factor_group()),
      alloy_sites_filter,
      {0, 0}}; // max length, for point clusters only (null orbit branch, point orbit branch)

    ConfigEnumInput reference_config_enum_input {configuration_L12};

    // Create ConfigEnumInput that are copies of `reference_config_enum_input` with orbit prototype
    // sites selected, for all orbits generated by "cluster_specs"
    std::vector<ConfigEnumInput> with_cluster_sites = select_cluster_sites(
                                                        reference_config_enum_input,
                                                        cluster_specs);

    // Expect 3 results: 1 unselected, 1 with an "A" site selected, and 1 with the "B" site selected
    EXPECT_EQ(with_cluster_sites.size(), 3);
    EXPECT_EQ(count_selected(with_cluster_sites, {0, 0, 0}), 1);
    EXPECT_EQ(count_selected(with_cluster_sites, {1, 0, 0}), 1);
    EXPECT_EQ(count_selected(with_cluster_sites, {0, 1, 0}), 1);

  }

  namespace {

    Eigen::Matrix3i _fcc_conventional_transf_mat() {
      Eigen::Matrix3i transf_mat;
      transf_mat << -1, 1, 1, 1, -1, 1, 1, 1, -1;
      return transf_mat;
    }

    Configuration _make_configuration_L12(std::shared_ptr<CASM::Structure const> shared_prim) {
      auto conventional_fcc = std::make_shared<Supercell>(shared_prim, _fcc_conventional_transf_mat());
      Configuration configuration {conventional_fcc};
      configuration.configdof().occ(0) = 1;
      return configuration;
    }

    Configuration _make_configuration_L12_3x3x3(Configuration const &_configuration_L12) {
      auto conventional_fcc_3x3x3 = std::make_shared<Supercell>(
                                      _configuration_L12.supercell().shared_prim(),
                                      3 * _fcc_conventional_transf_mat());
      return fill_supercell(_configuration_L12, conventional_fcc_3x3x3);
    }

    /// Check how many ConfigEnumInput have a matching number of each type of occupant on the selected sites
    ///
    /// Example, FCC ternary prim:
    /// - Count how many ConfigEnumInput in `with_cluster_sites` have 1 site occupied by an A atom,
    ///   2 sites occupied by a B atom, and 0 sites occupied by a C atom selected:
    ///       `count_selected(with_cluster_sites, {1, 2, 0})`
    Index count_selected(std::vector<ConfigEnumInput> const &with_cluster_sites, std::vector<Index> expected_occ_count) {

      Index matching = 0;
      for(ConfigEnumInput const &config_with_cluster : with_cluster_sites) {
        Configuration const &config = config_with_cluster.configuration();
        std::vector<Index> occ_count(0, expected_occ_counts.size());
        for(Index site_index : config_with_cluster.sites()) {
          occ_count[config.occ(site_index)]++;
        }
        if(occ_count == expected_occ_count) {
          matching++;
        }
      }
    }

  }
